---
title: "APSTA-2017 (Final Presentation)"
author: "William Spagnola"
date: "5/4/2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require(knitr)
require(tidyverse)
require(kableExtra)
require(tm)
require(tidytext)
require(tidyverse)
source('src/source.R')

#Read In Data
beatles <- read.csv( 'data/output/beatles_full.csv', stringsAsFactors = F)

#Relevel album_name factor to be in chronological order
album_chron_levels <- beatles %>% 
  group_by(album_name, album_release_date) %>% 
  count %>% 
  arrange(album_release_date) %>% 
  drop_na %>% 
  pull(album_name) 
beatles <- beatles %>% 
  mutate(album_name = factor(album_name, levels =album_chron_levels)
)


#Drop 'Besame Mucho' because it is a cover song 
beatles <- beatles %>%  filter(song != 'Besame Mucho')

```


#### Research Question
How did chord progressions in Beatles songs evolve over time? 

#### Research Objective
Using ngrams, build a model to classify Beatles as an 'early' or 'late' song. 

#### Why this matters?  (Or at the very least, why this matters to me?)
As I have worked on this project, I have noticed that it very difficult to describe its relevance because music is a very abstract thing.  If this were a research project on the use of color in paintings, for example, it would be more accessible because although many people may not have a deep understanding of color theory, but most have at least an understanding of color (i.e. they know what 'blue', 'red', and 'yellow' mean).  However, most people would probably not understand the meaning of a  'I-IV-V' or 'ii-V-I' chord progression unless they have taken a class in music theory. 

Consequently, my intended audience would be someone who already has a background in music theory and would be able to understand a basic chord progression written in roman numerical analysis.  My belief is that understanding how chord progressions in the music of Beatles changed over time will help musical historians to understand the compositional structure of their songs.  In addition, it will help musicians understand unique qualities in Beatles music that may inform their own compositions. The ultimate goal would be to present the findings in terms of chord sequences associated with each musical phase.  These findings should be relevant to a musician or music theorist even if they do not understand underlying statistical and machine learning methods that were used to discover these chord sequences. 

#### Early Beatles vs. Later Beatles
```{r  out.width = "50%", echo = F}
include_graphics('img/Beatles_Red_Album.jpg') 
include_graphics('img/Beatles_Blue_Album.jpg') 
```

When I was growing up, I was always fascinated by the two images from the Beatles first two compilation albums released after their break up.  The red album contains songs from 1962 to 1966 and the blue album contains songs from 1967 to 1970 (The actual cutoff date  is June 21, 1966).  The album covers show the fab four in the same location, but with wildly different hairstyles and clothing. The two albums contrast their early clean cut mop-top image  with their later long-haired, psychodelic stlye.  My goal with this project is to examine the stylistic progression of the Beatles by examining their most common chord progression during each of these phases.  In other words, I want to classify songs based on their chord progression as either belonging the 'red album' (early phase) or the 'blue album' (later phase).


#### Literature Review
I found two particularly relevant articles.  Douglas J. Mason, a Ph. D. student at Harvard, used hierarchical clustering techniques to examine chords in Beatles songs (2012).  He noticed certain clusters of songs based on the usage of 'borrowed chords'.  Borrowed chords are chords that do not belong to the key of the song but are 'borrowed' from a different scale.  The author noticed that these clusters generally contained songs that were from different albums.  However, the majority of the songs, which were taken from *Rolling Stone's* list of the Top 100 Beatles songs, were from their later period (1967 to 1970).

In another study, PÃ©rez-Sancho et. al employed text analysis techiniques such as bigrams and trigrams to build models for classifying musical pieces according to genre (2009).  Using this method, they were able to classify songs according to genre with 80% accuracy.  However, they did not achieve the same level of accuracy when classifying music according to sub-genres (e.g. classifying different types of music within the rock genre).

#### Data Collection 
To build a dataset of Beatles chord progressions, I created a webcrawler to scrape chords from Hooktheory.com.  Hooktheory contains over 12,000 songs, which includ a large number of Beatles songs. Each song is  divided according to different sections (e.g. Verse, Chorus, etc.).  The site does not contain the entire song but rather just the repeating pattern for each section.  Below, you can see the chords from the  verse from 'Hey Jude', which are repeated throughout the song. I was able to scrape the 'letter' chords but not the roman numerical analysis.  However, using the song key, which I also scraped from the site, I was able to build a function that converted the 'letter' chords into roman numerals.  As I will explain in the next session, the roman numerals represent each chord's position in a given key. 
```{r out.width = "100%", echo = F}
include_graphics('img/Hooktheory_Screen_Shot.png') 

```


#### Roman Numerical Analysis
You may notice in the image above, that the chords are represented by both letters and roman numerals.  The roman numerals represent the chord used relative to each key.  'Hey Jude' is written in the key of F major, so the F major chord can be represented with a 'I'.  Notice that when referring to major chords, it is often common practice to simply write a capital letter without writing 'major' (e.g. 'F' means 'F major' and 'C means 'C major').  

The next chord is a C.  The key of F contains the notes F, G, A, Bb, C, D, and E.  Notice that 'C' is the fifth note of the F scale.  Consequently, we can represent C with a 'V'.

Using roman numerical analysis, we can compare equivalent chord progressions in different keys.  For example, let's say we want to write a song in 'G major'.  Then a G major chord  would now be represented as 'I' and 'D major' would be represented as 'V'.  This is because D would be the fifth chord in the key of G (G, A, B, C, D, E, and F#)

```{r Roman Numerical Analysis}

key <- c('Fmaj', 'Gmaj')
roman <- c('I', 'ii', 'iii', 'IV', 'V or V7', 'vi', 'viio')
chords_F <- c('F', 'gm', 'am', 'Bb', 'C or C7', 'dm', 'eo')
chords_G <- c('G', 'am', 'bm', 'C', 'D or D7', 'em', 'f#o')

key <- data.frame(key, rbind(t(chords_F), t(chords_G)) )
names(key) <- c('key', roman)
key %>% 
  kable %>% 
  kable_styling
```
In the table above, you can see the chords found in G major and Fmajor.  Each column name represents the roman numeral that would be assigned to that chord based on the key.  Minor chords are generally represented by lower case letters and, in this case, also are followed by a lowercase 'm' (e.g. 'gm' represents g minor).  The circle in 'eo' and 'f#o' represent diminished chords, but they are much less common in rock music than major, minor and seventh chords.

It should be noted that this is a very basic introduction to music theory. You can read more about music theory in the music_theory.pdf file in the github repository.  

#### Songs Available on Hooktheory

```{r}
beatles %>% 
  count(phase, song) %>% 
  count(phase)
```


#### Songs Available on Hooktheory By Phase
```{r Barplot: Songs Available on Hooktheory By Phase}
beatles %>% 
  count(phase, song) %>% 
  count(phase) %>% 
  drop_na(phase) %>% 
  ggplot(aes(x = phase, y = nn, fill = phase)) +
  geom_col() +
  scale_fill_manual(values = c('red', 'blue' )) +
  ylab('Number of Songs') +
  ggtitle('Beatles Songs Available on Hook Theory') +
  scale_y_continuous(limits = c(0, 65), expand = c(0, 0)) +
  my_theme  

```

There were 37 songs available from the early phase and 63 songs from the later phase.  There were a total of 100 songs, which is the same as the sample size from the Beatles Genome {roject. 

#### Available Hooktheory Songs by Album
```{r Barplot: Available Hooktheory Songs by Album}
beatles %>% 
  count(album_name, year, song, phase) %>% 
  count(album_name, year, phase) %>% 
  drop_na(album_name) %>% 
  ggplot(aes(x = album_name, y = nn, fill = phase)) +
  geom_col() +
  scale_fill_manual(values = c('red', 'blue' )) +
  scale_y_continuous(expand = c(0,0), limits = c(0,20)) +
  xlab('Album Name') +
  ylab('Number of Songs') +
  geom_hline(yintercept = 12, lty = 'dashed', color = 'orange') +
  ggtitle('Beatles Songs Available on Hook Theory by Album') +
  my_theme_tilt
```
Songs from the *White Album* appear to be overrepresented.  However, the *White Album* contained 30 tracks, which is an unusually high number for a Beatles Album.  Songs from *Yellow Submarine*, *Let It Be* and many of the earlier albums appear to be underrepresented.  I added an orange dashed line at y=12 to represent the typical number of songs per album in order to portray a sense of how many songs are missing from each album.  


```{r Singles}
beatles %>%  
  filter(is.na(album_name)) %>% 
  distinct(artist, song, year, phase) %>% 
  arrange(year)

```
There were seven songs in the dataset that were singles and not associated with any album.  I searched online to find out the year that they were released, and I coded the phase accordingly. 


#### Mean Number of Unique Chords
```{r Line Graph: Mean Number of Unique Chords Per Song by Year}
beatles %>%
  group_by(song, year) %>% 
  summarize(num_chords = sum_chords_unique(chords)) %>% 
  group_by(year) %>% 
  summarize(mean_num_chords = mean(num_chords)) %>% 
  ggplot(aes(x = year, y = mean_num_chords)) +
  geom_line() +
  geom_point() +
  geom_vline(xintercept = 1966, lty = 'dashed', color = 'blue') +
  scale_x_discrete( limits =  1963:1970, breaks = 1963:1970) +
  scale_y_continuous(limits = c(0, 12), breaks = 0:12) +
  ggtitle('Mean Number of Unique Chords Per Song by Year') +
  xlab('Year') +
  ylab('Mean Chord Number') +
  my_theme

```

#### Mean Number of Unique Chords Per Song by Album
```{r Bar Plot: Mean Number of Unique Chords Per Song by Album}
beatles %>%
  group_by(song, album_name, phase) %>% 
  summarize(num_chords = sum_chords_unique(chords)) %>% 
  group_by(album_name, phase) %>% 
  summarize(mean_num_chords = mean(num_chords)) %>% 
  drop_na(album_name) %>% 
  ggplot(aes(x = album_name, y = mean_num_chords, fill = phase)) +
  geom_col() +
  ggtitle('Average Number of Chords per Song by Album') +
  xlab('Album') +
  ylab('Average Number of Chords') +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 10), breaks = seq(0, 10, 2)) +
  my_theme_tilt

```

*Revolver* and *Let it Be* seem to not follow the generally positive trend in the average number of chords per song over time. 

#### Line Graph: Mean Number of Unique Chords Per Song by Year (Grouped by Phase)
```{r Mean Number of Unique Chords Per Song by Year Grouped by Phase, echo=FALSE}
beatles %>%
  group_by(song, year, phase) %>% 
  summarize(num_chords = sum_chords_unique(chords)) %>% 
  group_by(year, phase) %>% 
  summarize(mean_num_chords = mean(num_chords)) %>% 
  ggplot(aes(x = year, y = mean_num_chords, color = phase, group = phase)) +
  geom_vline(xintercept = 1966, lty = 'dashed', color = 'blue') +
  geom_line() +
  geom_point(aes(group = phase, color = phase)) +
  scale_x_discrete( limits =  1963:1970, breaks = 1963:1970) +
  scale_y_continuous(limits = c(0, 12), breaks = seq(0, 12, 2)) +
  ggtitle('Mean Number of Unique Chords Per Song by Year (Grouped by Phase)') +
  xlab('Year') +
  ylab('Mean Chord Number') +
  my_theme

```


#### Table: Album/Single by Year
```{r Table: Album/Single by Year}
beatles %>%  
  mutate(name  = if_else(is.na(album_name)==T, song, as.character(album_name)),
         album_or_single = if_else(is.na(album_name)==T, 'Single', 'Album')) %>% 
  distinct(name, year, album_or_single, phase) %>% 
  arrange(year, phase) %>% 
  kable %>% 
  kable_styling

```
*Revolver* and *Let It Be* seem to not follow the general linear trend.   It is worth noting that the 'early' phase song in 1966 is 'Paperback Writer', which has only two chords listed on hooktheory. 


#### Borrowed Chords: *Their chords were outrageous, just outrageous* 
The Beatles often experimented with unusual chords in their songs.  In fact, Bob Dylan is quoted as saying that 'their chords were outrageous, just outrageous and their harmonies made it all valid' (Tomasky 2014).  While examining the dataset, I, like Bob Dylan, noticed that the Beatles used a lot of **borrowed chords**.  Borrowed chords are chords that are 'borrowed' from another key.  It is important to distinguish borrowed chords form modulation.   In modulation, the tone or key of the song actually changes, but with borrowed chords the key of the song remains the same despite the fact that the chord is not found in the original key.  Borrowed chords are also know as passing chords, which might be a useful way of thinking about them because they essentially 'pass' before the song has a chance to actually change key.  A good example is the verse 'For No One', which you can explore by clicking the link **[here](https://www.hooktheory.com/theorytab/view/the-beatles/for-no-one)**.  Click 'play', and listen carefully.  You will notice that the *Amaj*, sounds a little bit different from the other chords.  That is because all the other chords belong to *B major*, which is the key of the song.  However, *A major* is not found in the key of *B Major* and is actually borrowed from *B minor*.  However, in my opinion, the surprising presence of this chord adds tension to the song, which mirrors the tension of its lyrical theme of a relationship that is close to its end. 
```{r Calculate Borrowed Chords}

#Calculate Borrowed Chords and Number of Chords in Each Song
beatles$roman <- as.character(beatles$roman)
beatles$borrowed_pct <- beatles$roman %>% 
                      lapply(borrow_chord_pct) %>%  unlist
beatles$num_chords <- beatles$roman %>% 
                              str_split('-') %>% 
                              sapply(function(x) length(x))

#### Plot Percent Borrowed Chords ####
pct_borrowed_chord_tab <-beatles %>% 
                              mutate(wt_pct_borrowed =  borrowed_pct*num_chords  )%>% 
                              drop_na(album_name) %>% 
                              group_by(album_name, phase) %>% 
                              summarize(pct_borrowed_sum = sum(wt_pct_borrowed) / sum(num_chords))
pct_borrowed_chord_tab  %>% 
  kable %>% 
  kable_styling
```


**Important Point**
I think the particular quality the 'Amajor' chord evokes in the verse of 'For No One' is a perfect example of how the mathematical structure of a song can reveal a particular artistic/emotional quality.  I think that this example provides a much better explanation of the artistic relevance of the statistical analysis of chord progressions than anything I could possibly write. 

#####  Proportion of Borrowed Chords By Album 
```{r Barplot: Proportion of Borrowed Chords By Album}
pct_borrowed_chord_tab %>% 
  ggplot(aes(x = album_name, y= pct_borrowed_sum, fill = phase)) + 
  geom_col() +
  scale_y_continuous(expand = c(0,0), 
                     limits = c(0, 0.5), 
                     breaks = seq(0, 0.4, .1)) +
  ggtitle('Proportion of Borrowed Chords By Album') +
  xlab('Album Name') +
  ylab('Proportion') +
  my_theme_tilt 
```
In general, songs from albums in the later phase tend to have a higher proportion of borrowed chords.  However, *Rubber Soul* has a high proportion of borrowed chords despite being classified in the early phase (although it is the last album before the cutoff) and *Let It Be* has a low proportion of borrowed chords despite being released in 1970.  These trends mirror the trends from average number of chords per song plots.

### Bigrams
```{r Construct Bigrams}

#Split each song into a separate dataframe 
#Bind Songs into data.frame
#This creates a data.frame where each row is one song
#where roman represents all the chords in the song
l <- beatles %>%  
          split(f = beatles$song) %>% 
          lapply(function(x) data.frame(artist = unique(x$artist), 
                                song = unique(x$song), 
                                roman = paste(x$roman, collapse = '-')))
df <- suppressWarnings(bind_rows(l)) 

#Deal with borrow chords (slashes will be considered separate ngrams)
#Then Create bigrams
bigrams <- df %>%  
      mutate(roman = str_replace_all(roman, '-', ' ')) %>% 
      mutate(roman = str_remove_all(roman, '\\(')) %>% 
      mutate(roman = str_remove_all(roman, '\\)')) %>% 
      mutate(roman = str_replace_all(roman, '/', 'BORROWED')) %>% 
      unnest_tokens(bigram, roman, token = 'ngrams', n = 2,
                    to_lower = F) %>%  
      count(song, bigram) %>% 
      mutate(bigram = if_else(grepl('\\s+[a-z]+BORROWED', bigram),
                              paste0(bigram, ')'), bigram),
             bigram = if_else(grepl('\\s+[A-Z]+BORROWED', bigram),
                              paste0(bigram, ')'), bigram),
            bigram = if_else(grepl('BORROWED+[a-z]+\\s', bigram), 
                             str_replace(bigram, ' ', '\\) '), bigram),
              bigram = if_else(grepl('BORROWED+[A-Z]+\\s', bigram), 
                             str_replace(bigram, ' ', '\\) '), bigram),
             bigram = str_replace_all(bigram, 'BORROWED', '/\\('),
             bigram = str_replace_all(bigram, '\\s', '-')) %>% 
      select(song, bigram, n) 

#Remove bigrams with same chords
bigrams <- bigrams %>% 
              separate(bigram, c('chord_1', 'chord_2'), sep = "-") %>% 
              filter(chord_1 != chord_2) %>% 
              unite(bigram, chord_1, chord_2, sep = "-")

#Get Song Info
song_info <-beatles %>% 
              select(song, album_name, year, phase)

bigram_info <- bigrams %>% 
                   left_join(song_info, by = 'song')
```

#### Top 10 Bigrams: Early Beatles (NO Features)
```{r Top 10 Bigrams: Early Beatles}
early_bigrams <- bigram_info %>% 
                    filter(phase == 'Early') %>% 
                    group_by(phase, bigram) %>% 
                    summarize(n = sum(n)) %>% 
                    arrange(desc(n)) 

early_bigrams %>% 
     slice(1:10)

```


### Top 10 Bigrams: Late Beatles (NO Features)
```{r Top 10 Bigrams: Late Beatles}

late_bigrams <- bigram_info %>% 
                    filter(phase == 'Late') %>% 
                    group_by(phase, bigram) %>% 
                    summarize(n = sum(n)) %>% 
                    arrange(desc(n)) 

late_bigrams %>% 
  slice(1:10)

```




###Trigrams
```{r Construct Trigrams}

# #Remove Duplicate chords in sequence 
# df$roman <- df$roman %>%  
#                 sapply(remove_duplicates)
# 
# #Deal with borrow chords (slashes will be considered separate ngrams)
# #Then Create trigrams
# trigrams <- df %>%  
#       mutate(roman = str_replace_all(roman, '-', ' ')) %>% 
#       mutate(roman = str_remove_all(roman, '\\(')) %>% 
#       mutate(roman = str_remove_all(roman, '\\)')) %>% 
#       mutate(roman = str_replace_all(roman, '/', 'BORROWED')) %>% 
#       unnest_tokens(trigram, roman, token = 'ngrams', n = 3,
#                     to_lower = F) %>%  
#       count(song, trigram) %>% 
#       select(song, trigram, n) 
# 
# trigrams$trigram <- trigrams$trigram %>%  
#                       str_split(pattern = '\\s', simplify = F) %>% 
#                       lapply(function(x) paste0(x, ifelse(grepl('BORROWED',x), ')', ''))) %>% 
#                       lapply(function(x) x %>%  str_replace(pattern = 'BORROWED', '/\\(')) %>% 
#                       lapply(function(x) paste(x, collapse = '-')) %>% 
#                       unlist 
# 
# #Get Song Info
# song_info <-beatles %>% 
#               select(song, album_name, year, phase)
# 
# trigram_info <- trigrams %>% 
#                    left_join(song_info, by = 'song')
```


### Top 10 Trigrams: Early Beatles (No Features)
```{r Top 10 Trigrams: Early Beatles}
early_trigrams<- trigram_info %>% 
                    filter(phase == 'Early') %>% 
                    group_by(phase, trigram) %>% 
                    summarize(n = sum(n)) %>% 
                    arrange(desc(n)) 
early_trigrams  %>% 
  slice(1:10)%>% 
  kable %>% 
  kable_styling

```



###Top 10 Trigrams: Late Beatles (No Features)
```{r Top 10 Trigrams: Late Beatles}
late_trigrams <- trigram_info %>% 
                    filter(phase == 'Late') %>% 
                    group_by(phase, trigram) %>% 
                    summarize(n = sum(n)) %>% 
                    arrange(desc(n))
late_trigrams %>% 
  slice(1:10) %>% 
  kable %>% 
  kable_styling

```



### Construct Bigrams with Features
```{r Construct Bigrams with Features}
#Split each song into a separate dataframe 
#Bind Songs into data.frame
#This creates a data.frame where each row is one song
#where roman_features represents all the chords in the song
l <- beatles %>%  
          split(f = beatles$song) %>% 
          lapply(function(x) data.frame(artist = unique(x$artist), 
                                song = unique(x$song), 
                                roman_features= paste(x$roman_features, collapse = '-')))
df_features <- suppressWarnings(bind_rows(l)) 

#Deal with borrow chords (slashes will be considered separate ngrams)
#Then Create bigrams
bigrams_features <- df_features %>%  
      mutate(roman_features = str_replace_all(roman_features, '-', ' ')) %>% 
      mutate(roman_features = str_remove_all(roman_features, '\\(')) %>% 
      mutate(roman_features = str_remove_all(roman_features, '\\)')) %>% 
      mutate(roman_features = str_replace_all(roman_features, '/', 'BORROWED')) %>% 
      unnest_tokens(bigram, roman_features, token = 'ngrams', n = 2,
                    to_lower = F) %>%  
      count(song, bigram) %>% 
      mutate(bigram = if_else(grepl('\\s+[a-z]+BORROWED', bigram),
                              paste0(bigram, ')'), bigram),
             bigram = if_else(grepl('\\s+[A-Z]+BORROWED', bigram),
                              paste0(bigram, ')'), bigram),
            bigram = if_else(grepl('BORROWED+[a-z]+\\s', bigram), 
                             str_replace(bigram, ' ', '\\) '), bigram),
              bigram = if_else(grepl('BORROWED+[A-Z]+\\s', bigram), 
                             str_replace(bigram, ' ', '\\) '), bigram),
             bigram = str_replace_all(bigram, 'BORROWED', '/\\('),
             bigram = str_replace_all(bigram, '\\s', '-')) %>% 
      select(song, bigram, n) 

#Remove bigrams with same chords
bigrams_features  <- bigrams_features  %>% 
              separate(bigram, c('chord_1', 'chord_2'), sep = "-") %>% 
              filter(chord_1 != chord_2) %>% 
              unite(bigram, chord_1, chord_2, sep = "-")

#Get Song Info
song_info <-beatles %>% 
              select(song, album_name, year, phase)

bigrams_features_info <- bigrams_features %>% 
                   left_join(song_info, by = 'song')

```



#### Top 10 Bigrams (with FEATURES) : Early Beatles
```{r Top 10 Bigrams (with FEATURES): Early Beatles}
early_bigrams_features<- bigrams_features_info %>% 
                    filter(phase == 'Early') %>% 
                    group_by(phase, bigram) %>% 
                    summarize(n = sum(n)) %>% 
                    arrange(desc(n))


early_bigrams_features %>% 
  slice(1:10) %>% 
  kable %>% 
  kable_styling


```



#### Top 10 Bigrams (with FEATURES) : Late Beatles
```{r Top 10 Bigrams (with FEATURES): Late Beatles}
late_bigrams_features <- bigrams_features_info %>% 
                              filter(phase == 'Late') %>% 
                              group_by(phase, bigram) %>% 
                              summarize(n = sum(n)) %>% 
                              arrange(desc(n))
late_bigrams_features %>% 
  slice(1:10) %>% 
  kable %>% 
  kable_styling

```

In both cases, there are some dominant 7 in the top 10, but not any other chords beyond major and minor chords. 


#### Construct Trigrams with FEATURES
```{r Construct Trigrams with FEATURES}

#Remove Duplicate chords in sequence 
df_features$roman_features <- df_features$roman_features %>%  
                                            sapply(remove_duplicates)

#Deal with borrow chords (slashes will be considered separate ngrams)
#Then Create trigrams
trigrams_features <- df_features %>%  
      mutate(roman_features = str_replace_all(roman_features, '-', ' ')) %>% 
      mutate(roman_features = str_remove_all(roman_features, '\\(')) %>% 
      mutate(roman_features = str_remove_all(roman_features, '\\)')) %>% 
      mutate(roman_features = str_replace_all(roman_features, '/', 'BORROWED')) %>% 
      unnest_tokens(trigram, roman_features, token = 'ngrams', n = 3,
                    to_lower = F) %>%  
      count(song, trigram) %>% 
      select(song, trigram, n) 

trigrams_features$trigram <-trigrams_features$trigram %>%  
                      str_split(pattern = '\\s', simplify = F) %>% 
                      lapply(function(x) paste0(x, ifelse(grepl('BORROWED',x), ')', ''))) %>% 
                      lapply(function(x) x %>%  str_replace(pattern = 'BORROWED', '/\\(')) %>% 
                      lapply(function(x) paste(x, collapse = '-')) %>% 
                      unlist 
#Get Song Info
song_info <-beatles %>% 
              select(song, album_name, year, phase)

trigrams_features_info <- trigrams_features %>% 
                   left_join(song_info, by = 'song')
```

One of the first things I noticed is that the earlier songs had a minor key progression in the top 10 trigrams.  In addition, the second most common trigram in the early period was 'ii-V-I', which actually a chord progression normally associated with jazz music.  On the other hand, there seemed to be more of a variety of borrowed chords in the later phase.  The 'V/(V)' chord (this is when the third chord of the scale is played as a major chord instead of a minor chord) was the only borrowed chord in the top 10 trigrams from the early phase. 

### Top 10 Trigrams with FEATURES: Early Beatles
```{r Top 10 Trigrams with FEATURES: Early Beatles}

# Keep early songs; Calculate sum by aggregated by phase and trigram; arrange in descending order
early_trigrams_features <- trigrams_features_info %>% 
                    filter(phase == 'Early') %>% 
                    group_by(phase, trigram) %>% 
                    summarize(n = sum(n)) %>% 
                    arrange(desc(n)) 

#Plot top 10 early trigrams
early_trigrams_features %>% 
  slice(1:10) %>% 
  kable %>% 
  kable_styling

```


### Top 10 Trigrams with FEATURES: Late Beatles
```{r Top 10 Trigrams with FEATURES: Late Beatles}
late_trigrams_features <- trigrams_features_info %>% 
                                      filter(phase == 'Late') %>% 
                                      group_by(phase, trigram) %>% 
                                      summarize(n = sum(n)) %>% 
                                      arrange(desc(n)) 
late_trigrams_features %>% 
  slice(1:10) %>% 
  kable %>% 
  kable_styling

```


#### Document Term Matrix: Bigrams 
```{r Document Term Matrix (Bigrams), message = F}
top_bigrams <- bigrams  %>%
                      count(bigram, sort = T) %>%
                      slice(1:100) %>%
                      select(bigram)
         
#Create document-term matrix   
dtm <- bigrams %>% 
          inner_join(top_bigrams) %>% 
          cast_dtm(document = song, term = bigram,  value = n, weighting = tm::weightTfIdf)
dtm_tibble <-  cbind(dtm$dimnames$Docs, as.matrix(dtm)) %>% as.tibble()

#Convert td*idf to numeric 
dtm_tibble <- dtm_tibble %>% 
                mutate_if(grepl('-', names(dtm_tibble)), as.numeric)


#Rename first variable as song; join dtm with other data
names(dtm_tibble)[grep('V1', names(dtm_tibble))] <- 'song'
dtm_song_info <- dtm_tibble  %>% 
                    left_join(song_info)

#Display subset of columns from document-term matrix
dtm_song_info[1:10, 1:8] %>%
    mutate_if(is.numeric, function(.) round(., 2)) %>% 
    kable %>% 
    kable_styling 
   
```

#### Document Term Matrix: Trigrams 
```{r Document Term Matrix: Trigrams, message = F}
top_trigrams <- trigrams  %>%
                      count(trigram, sort = T) %>%
                      slice(1:100) %>%
                      select(trigram)
         
#Create document-term matrix   
dtm <- trigrams %>% 
          inner_join(top_trigrams) %>% 
          cast_dtm(document = song, term = trigram,  value = n, weighting = tm::weightTfIdf)
dtm_tibble <-  cbind(dtm$dimnames$Docs, as.matrix(dtm)) %>% as.tibble()

#Convert td*idf to numeric 
dtm_tibble <- dtm_tibble %>% 
                mutate_if(grepl('-', names(dtm_tibble)), as.numeric)


#Rename first variable as song; join dtm with other data
names(dtm_tibble)[grep('V1', names(dtm_tibble))] <- 'song'
dtm_trigrams <- dtm_tibble  %>% 
                    left_join(song_info)

#Display subset of columns from document-term matrix
dtm_trigrams[1:10, 1:8] %>%
    mutate_if(is.numeric, function(.) round(., 2)) %>% 
    kable %>% 
    kable_styling 
   
```




#### Document Term Matrix: Bigrams with FEATURES
```{r Document Term Matrix: Bigrams with FEATURES, message = F}
top_bigrams_features <- bigrams_features  %>%
                      count(bigram, sort = T) %>%
                      slice(1:100) %>%
                      select(bigram)
   
#Create document-term matrix   
dtm <- bigrams_features %>% 
          inner_join(top_bigrams_features) %>% 
          cast_dtm(document = song, term = bigram,  value = n, weighting = tm::weightTfIdf)
dtm_tibble <-  cbind(dtm$dimnames$Docs, as.matrix(dtm)) %>% as.tibble()

#Convert td*idf to numeric 
dtm_tibble <- dtm_tibble %>% 
                mutate_if(grepl('-', names(dtm_tibble)), as.numeric)


#Rename first variable as song; join dtm with other data
names(dtm_tibble)[grep('V1', names(dtm_tibble))] <- 'song'
dtm_bigrams_features <- dtm_tibble  %>% 
                    left_join(song_info)

#Display subset of columns from document-term matrix
dtm_bigrams_features[1:10,1:8] %>%
    mutate_if(is.numeric, function(.) round(., 2)) %>% 
    kable %>% 
    kable_styling 
```

#### Document Term Matrix: Trigrams with FEATURES
```{r Document Term Matrix: Trigrams with FEATURES, message = F}
top_trigrams_features <- trigrams_features %>%
                      count(trigram, sort = T) %>%
                      slice(1:100) %>%
                      select(trigram)
         
#Create document-term matrix   
dtm <- trigrams_features %>% 
          inner_join(top_trigrams_features) %>% 
          cast_dtm(document = song, term = trigram,  value = n, weighting = tm::weightTfIdf)
dtm_tibble <-  cbind(dtm$dimnames$Docs, as.matrix(dtm)) %>% as.tibble()

#Convert td*idf to numeric 
dtm_tibble <- dtm_tibble %>% 
                mutate_if(grepl('-', names(dtm_tibble)), as.numeric)


#Rename first variable as song; join dtm with other data
names(dtm_tibble)[grep('V1', names(dtm_tibble))] <- 'song'
dtm_trigrams_features <- dtm_tibble  %>% 
                            left_join(song_info)

#Display subset of columns from document-term matrix
dtm_trigrams_features[, 1:8] %>%
    mutate_if(is.numeric, function(.) round(., 2)) %>% 
    slice(1:10) %>% 
    kable %>% 
    kable_styling 

```


#### Early Beatles Word Cloud  (Bigrams; NO Features)
```{r}
wordcloud(early_bigrams$bigram,
          early_bigrams$n,
          max.words=20,
          scale = c(4, 1),
          random.order = F, 
          colors=pal_red )

```

#### Late Beatles Word Cloud  (Bigrams; NO Features)
```{r}
wordcloud(late_bigrams$bigram,
          late_bigrams$n,
          max.words=20,
          scale = c(4, 1),
          random.order = F, 
          colors=pal_blue)

```


#### Early Beatles Word Cloud  (Trigrams; NO Features)
```{r}
wordcloud(early_trigrams$trigram,
          early_trigrams$n,
          max.words=20,
          scale = c(2.8, 1),
          random.order = F, 
          colors=pal_red )
```



#### Late Beatles Word Cloud  (Trigrams; NOFeatures)
```{r}
wordcloud(late_trigrams$trigram,
          late_trigrams$n,
          max.words=20,
          scale= c(2.8, 1),
          random.order = F, 
          colors=pal_blue)
```


#### Late Beatles Word Cloud  (Bigrams with Features)
```{r}
wordcloud(late_bigrams_features$bigram,
          late_bigrams_features$n,
          max.words=50,
          random.order = F, 
          colors=pal_blue)

```


#### Early Beatles Word Cloud  (Trigrams with Features)
```{r Word Cloud}
#Early Beatles Word Cloud 
wordcloud(early_trigrams_features$trigram,
          early_trigrams_features$n,
          max.words=20,
          random.order = F, 
          colors=pal_red )
```



#### Late Beatles Word Cloud   (Trigrams with Features)
```{r}
wordcloud(late_trigrams_features$trigram,
         late_trigrams_features$n,
          scale = c(1, 2.5),
          max.words=30,
          random.order = F, 
          colors=pal_blue)

```






```{r}

top_bigrams <- bigram_info %>%
                     distinct(song, bigram) %>% 
                      count(bigram, sort = T) %>% 
                      slice(1:50)



#Create document-term matrix   
dtm <- bigrams %>% 
          inner_join(top_bigrams, by = "bigram") %>% 
          cast_dtm(document = song, term = bigram,  value = n.x, weighting = tm::weightTfIdf)


dtm <- bigrams %>% 
          cast_dtm(document = song, term = bigram,  value = n, weighting = tm::weightTfIdf)


dtm_tibble <-  cbind(dtm$dimnames$Docs, as.matrix(dtm)) %>% as.tibble()
dtm_tibble <- dtm_tibble %>% 
                  rename('song' = 'V1')

dtm_tibble <- dtm_tibble %>% 
                      mutate_if(.predicate = grepl('song', names(dtm_tibble))==F, as.numeric)

phase_info <- song_info %>% 
                 distinct(song, phase) 
mod_data <- dtm_tibble %>% 
                left_join(phase_info) %>% 
                select(phase, everything(), - song)


train_idx <- sample(1:nrow(mod_data), round(.5*nrow(mod_data)))
train_data <- mod_data[train_idx ,]
test_data <- mod_data[-train_idx ,]

require(glmnet)
require(naivebayes)

x_train <- train_data %>%  
        select(-phase) %>% 
         mutate_all(.funs = function(.) ifelse(. > 0, as.integer(1), as.integer(0))) %>% 
        as.matrix 
x_test <- test_data %>%  
        select(-phase) %>% 
         mutate_all(.funs = function(.) ifelse(. > 0, as.integer(1), as.integer(0))) %>% 
        as.matrix 
bernoulli_mod <- bernoulli_naive_bayes(x = x_train, 
                                       y =train_data$phase,
                                       laplace = .8)
predict(bernoulli_mod )
preds <- predict(bernoulli_mod, newdata = x_test)
table(test_data$phase, preds)
colnames(x_train) %>%  length
colnames(x_test) %>%  length
mean(x_train ==1)

lambda <- cv.glmnet(x = x_train, y = as.factor(train_data$phase), family = "binomial", alpha = 0)
fit_ridge <- glmnet(x = x_train, y = as.factor(train_data$phase),
                   lambda = lambda$lambda.1se, family = "binomial", alpha = 0)
predict(fit_ridge, newx = x_train, type = "response")


lambda <- cv.glmnet(x = x_train, y = as.factor(train_data$phase), family = "binomial", alpha = 1)
fit_lasso <- glmnet(x = x_train, y = as.factor(train_data$phase),
                   lambda = lambda$lambda.1se, family = "binomial", alpha = 1)
predict(fit_lasso, newx = x_train, type = "response")
fit_lasso %>% coef

predict(fit_ridge, newx = x_train, type = "class")
x_test  <- test_data %>% 
                select(-phase) %>% 
                as.matrix
predict(fit_ridge, newx = x_test, type = "class" )

?glmnet
nb_mod <- naiveBayes(as.factor(phase)~., train_data, laplace = 1)
pred <- predict(nb_mod, newdata = test_data, type = 'raw') %>%  
                tidy %>% 
                round(3) %>% 
                mutate(pred = if_else(Late > Early, 'Late', 'Early')) %>% 
                pull(pred)


table(test_data$phase, pred)
```

```{r}
#Remove Duplicate chords in sequence 
df_features$roman_features <- df_features$roman_features %>%  
                                            sapply(remove_duplicates)

#Deal with borrow chords (slashes will be considered separate ngrams)
#Then Create trigrams
one_grams_features <- df_features %>%  
      mutate(roman_features = str_replace_all(roman_features, '-', ' ')) %>% 
      mutate(roman_features = str_remove_all(roman_features, '\\(')) %>% 
      mutate(roman_features = str_remove_all(roman_features, '\\)')) %>% 
      mutate(roman_features = str_replace_all(roman_features, '/', 'BORROWED')) %>% 
      unnest_tokens(one_gram, roman_features, token = 'ngrams', n = 1,
                    to_lower = F) %>%  
      count(song, one_gram) %>% 
      select(song, one_gram, n) 

one_grams_features$one_gram <-trigrams_features$trigram %>%  
                      str_split(pattern = '\\s', simplify = F) %>% 
                      lapply(function(x) paste0(x, ifelse(grepl('BORROWED',x), ')', ''))) %>% 
                      lapply(function(x) x %>%  str_replace(pattern = 'BORROWED', '/\\(')) %>% 
                      lapply(function(x) paste(x, collapse = '-')) %>% 
                      unlist 

dtm <- one_grams_features %>% 
  cast_dtm(term = one_gram , document = song, value = n, weighting = tm::weightTf)

dtm_tibble <-  cbind(dtm$dimnames$Docs, as.matrix(dtm)) %>% as.tibble()

?cast_dtm
one_gram_info <- dtm_tibble %>%  
                    left_join(song_info, c('V1' = 'song')) %>% 
                    rename(song = V1) %>% 
                    distinct(song, .keep_all =T) %>% 
                    select(song, phase, everything()) %>% 
                    select(-album_name, - year)
x_data <- one_gram_info %>% 
                select(-song, -phase) %>% 
                mutate_all(function(.) if_else(. > 0, 1, 0)) %>% 
                mutate_all(as.integer) %>% 
                as.matrix
train_idx <- sample(1:nrow(mod_data), round(.5*nrow(mod_data)))
x_train <-x_data[train_idx ,]
x_test <-x_data[-train_idx ,]         
y_train <- mod_data[train_idx , ]$phase
y_test <-  mod_data[-train_idx , ]$phase
nb_mod <- bernoulli_naive_bayes(x = x_train, y = y_train, laplace = 1)
preds <- predict(nb_mod, newdata = x_test)
table(y_train, preds)
accuracy(table(preds, y_train))
accuracy <- function(tab){
  
  correct <- tab %>%  diag %>%  sum
  total  <- tab %>%   sum
  return(correct / total)

}
?distinct
```
```{r}


df <- one_grams_features %>% 
  select(song, one_gram) %>% 
  left_join(phase_info) 


phase_list <- split(x = df$one_gram, f = df$phase)
early_ngrams <- phase_list[[1]]
late_ngrams <- phase_list[[2]]
anti_list <- (early_ngrams %in% late_ngrams) ==F
early_ngrams[anti_list]


anti_list <- (late_ngrams %in% early_ngrams ) ==F
late_ngrams[anti_list]
```


```{r}

df_phase <- bigrams_features_info %>%
                distinct(song, bigram, .keep_all = T) %>% 
                count(phase, bigram, sort = T) 

df_phase %>% 
  spread(key = phase, value =nn, fill = 0)%>% 
      mutate(diff = Early - Late) %>% 
      arrange(desc(diff))



df_phase <- trigrams_features_info %>%
                distinct(song, trigram, .keep_all = T) %>% 
                count(phase, trigram, sort = T) 


diff_df <- df_phase %>% 
  spread(key = phase, value =nn, fill = 0)%>% 
      mutate(diff = Early - Late) %>% 
      arrange(desc(diff)) 

trigram_vec <- diff_df[c(1:25, (nrow(diff_df)-25):nrow(diff_df)) , ]$trigram


trigram_

df_phase <- trigram_info %>%
                distinct(song, trigram, .keep_all = T) %>% 
                count(phase, trigram, sort = T) 


diff_df <- df_phase %>% 
  spread(key = phase, value =nn, fill = 0)%>% 
      mutate(diff = Early - Late) %>% 
      arrange(desc(diff)) 

trigram_vec <- diff_df[c(1:25, (nrow(diff_df)-25):nrow(diff_df)) , ]$trigram


```


```{r}

l <- beatles %>%  
          split(f = beatles$song) %>% 
          lapply(function(x) data.frame(artist = unique(x$artist), 
                                song = unique(x$song), 
                                roman_features= paste(x$roman_features, collapse = '-')))
df_features <- suppressWarnings(bind_rows(l)) 
  


beatles_song_info <- beatles %>% 
                          distinct(song, year, phase, album_name)
beatles_song_features <-  df_features %>% 
                                left_join(beatles_song_info) %>% 
                                distinct(song, .keep_all = T)

```


```{r}
#Calculate Borrowed Chords and Number of Chords in Each Song
beatles_song_features$borrowed_pct <-beatles_song_features $roman_features %>% 
                      lapply(borrow_chord_pct) %>%  unlist
beatles_song_features$num_chords <- beatles_song_features$roman_features %>% 
                              str_split('-') %>% 
                              sapply(function(x) length(x)) 

beatles_song_features$minor_pct <-beatles_song_features $roman_features %>% 
                          str_split('-') %>% 
                          sapply(detect_minor)


beatles_song_features$dom_pct <- beatles_song_features$roman_features %>% 
                          str_split('-') %>% 
                          sapply(detect_dom_7)


beatles_song_features $maj_7_pct <- beatles_song_features$roman_features %>% 
                          str_split('-') %>% 
                          lapply(function(x) sum(str_detect(x, 'maj7') ))  %>% 
                          unlist


beatles_song_features$min_7_pct <- beatles_song_features$roman_features %>% 
                          str_split('-') %>% 
                          sapply(detect_minor_7 )

#### Plot Percent Borrowed Chords ####
pct_chord_tab <-  beatles_song_features  %>% 
                              mutate(wt_pct_borrowed =  borrowed_pct*num_chords) %>% 
                              distinct(song, .keep_all = T) %>% 
                              group_by(song, album_name, phase, year) %>% 
                              summarize(num_chords = sum(num_chords),
                                        pct_borrowed_sum = sum(wt_pct_borrowed) / num_chords,
                                        pct_minor_sum = sum(minor_pct) / num_chords,
                                        pct_dom_sum = sum(dom_pct) /  num_chords,
                                        pct_maj_7_sum =sum( maj_7_pct) / num_chords,
                                        pct_min_7_sum = sum(min_7_pct) / num_chords,) 
  

pct_chord_tab %>% 
  drop_na(album_name) %>% 
  ggplot(aes(x = pct_dom_sum, y = pct_borrowed_sum, 
             color = album_name)) +
  geom_point()
```


```{r}
pct_chord_tab %>% 
  drop_na(album_name) %>% 
  ggplot(aes(x = pct_dom_sum, y = pct_borrowed_sum)) +
  geom_point()  +
  facet_wrap(~ album_name)
 
```

```{r}
pct_chord_tab %>% 
  drop_na(album_name) %>% 
  ggplot(aes(x = pct_minor_sum, y = pct_borrowed_sum)) +
  geom_point()  +
  facet_wrap(~ album_name)
 
```



```{r}
pct_chord_tab %>% 
  drop_na(album_name) %>% 
  ggplot(aes(x = pct_minor_sum, y = pct_dom_sum)) +
  geom_point()  +
  facet_wrap(~ album_name)
 
```


```{r}
pct_chord_tab %>% 
  drop_na(album_name) %>% 
  ggplot(aes(x = pct_dom_sum, y = pct_maj_7_sum)) +
  geom_point()  +
  facet_wrap(~ album_name)
 
```


```{r}
# pct_df <- pct_chord_tab  %>% 
#                 ungroup %>%
#                 dplyr::select(song, starts_with('pct_')) 


pct_df <- pct_chord_tab  %>% 
                ungroup %>%
                dplyr::select(pct_borrowed_sum, pct_dom_sum, pct_minor_sum)

hc <- pct_df %>% 
          dplyr::select(starts_with('pct_')) %>% 
          dist() %>% 
          hclust(method = 'complete')

plot(hc)
h_cut <- .5
abline(h = h_cut , lty = 'dashed', col = 'red')
groups <- cutree(hc, h = h_cut )



# More than one album?
pct_chord_tab %>% 
  ungroup %>% 
  count(song) %>% 
  filter(n > 1)

pct_chord_tab$group <- groups
pct_chord_tab %>% 
  ungroup %>% 
  count(year, group) %>% 
  ggplot(aes(x = year, y = n, fill = as.factor(group))) +
  geom_col(position = 'fill')



```

```{r}
pct_chord_tab %>% 
  ggplot(aes(x = year, y = as.factor(groups), color = as.factor(groups))) +
  geom_point() +
  geom_jitter()
```

```{r}
# distinct_songs <- pct_chord_tab %>% 
#                   ungroup %>% 
#                   distinct(song, groups)
# 
# 
# 
# group_1  %>% 
#   full_join(beatles, by = 'song')
# beatles

for(i in 1:length(unique(pct_chord_tab$group))){
      group_i <- pct_chord_tab %>% filter(group == i)
      print(group_i)
  
}



```




```{r}
plot_groups <- distinct_songs %>% 
                  left_join(pct_df, by = 'song') %>%
                  mutate(groups = as.factor(groups))
 plot_groups %>% 
   ggplot(aes(x = pct_borrowed_sum, y = pct_dom_sum, 
             color = groups)) +
    geom_point()
 
 
  plot_groups %>% 
   ggplot(aes(x = pct_minor_sum, y = pct_dom_sum, 
             color = groups)) +
    geom_point()

  
  plot_groups %>% 
   ggplot(aes(x = pct_minor_sum, y = pct_maj_7_sum, 
             color = groups)) +
    geom_point()
  
  
plot_groups %>% 
   ggplot(aes(x = pct_min_7_sum, y = pct_maj_7_sum, 
             color = groups)) +
    geom_point() +
    geom_jitter()
  
  
  plot_groups %>% 
    count(groups)
```






```{r}

pct_df <- pct_chord_tab  %>% 
                ungroup %>%
                dplyr::select(song, starts_with('pct_')) 

pct_features <- pct_df %>% 
          dplyr::select(starts_with('pct_')) 


k_cluster <- kmeans(pct_features, centers = 6)
length(k_cluster$cluster)
pct_chord_tab$cluster <- k_cluster$cluster
pct_chord_tab %>% 
  mutate(cluster = cluster) %>% 
  ggplot(aes(x = year, y = cluster, color = as.factor(cluster))) +
  geom_point() +
  geom_jitter()


```


```{r}

k_cluster$centers %>% 
      as.data.frame %>% 
      mutate(cluster = row_number()) %>% 
      select(cluster, everything()) %>%
      gather(key = pct_feature, value = pct_value, - cluster) %>% 
      ggplot(aes(x = cluster, y = pct_value)) +
      geom_line() +
      facet_wrap(~pct_feature)



```




```{r}

unique(bigram_info$bigram) 


trigrams_binary <- dtm_trigrams %>% 
                        select(-album_name, -year, - phase) %>% 
                        mutate_if(is.numeric, function(.) if_else(. > 0, 1, 0))

trigram_dist <- trigrams_binary %>% 
                        distinct(song, .keep_all = T) %>% 
                        select(-song) %>% 
                        dist(method = 'manhattan')

hclust(trigram_dist) %>% 
  plot
bigram_info


```
```{r}
l <- beatles %>%  
          split(f = beatles$song) %>% 
          lapply(function(x) data.frame(artist = unique(x$artist), 
                                song = unique(x$song), 
                                roman= paste(x$roman, collapse = '-')))
df_triads <- suppressWarnings(bind_rows(l)) 



df_triad_bigrams <- df_triads %>% 
                         mutate(roman = str_replace_all(roman, '/', 'BORROWED'),
                                roman = str_remove_all(roman, '\\('),
                                roman = str_remove_all(roman, '\\)')) %>% 
                        unnest_tokens(bigram, roman, token = 'ngrams', n = 2,
                                        to_lower = F)  
#Replace as /(*)
df_triad_bigrams$bigram <- df_triad_bigrams$bigram %>% 
                        lapply(function(x) {
                                  x_chord <- str_split(x, pattern = '\\s', simplify = T)
                             
                                  borrow_logical <- grepl('BORROWED',x_chord)
                               
                                  x_chord[borrow_logical] <- paste0(x_chord[borrow_logical], ')')
                                  new_x <- paste(x_chord, collapse = ' ')
                                  new_x <- str_replace_all(new_x, "BORROWED", "/(")
                                  return(   new_x)}) %>% 
                                   unlist
        

top_20_triad_bigrams <- df_triad_bigrams  %>% 
                            distinct(song, bigram) %>% 
                            count( bigram, sort = T) %>% 
                            slice(1:25)



dtm_triad_bigrams <- df_triad_bigrams %>%
                          distinct(song, bigram) %>% 
                          inner_join(top_20_triad_bigrams, by = 'bigram') %>% 
                          mutate(n = 1) %>% 
                          cast_dtm(document = song, 
                                   term = bigram,
                                   value = n, 
                                   weighting = tm::weightTf)

 
#Convert from DTM into Tibble (WRITE FUNCTION FOR THIS)
dtm_triad_bigrams_tibble <-  cbind(dtm_triad_bigrams $dimnames$Docs, 
                                      as.matrix(dtm_triad_bigrams )) %>% 
                                      as.tibble()
dtm_triad_bigrams_tibble <- dtm_triad_bigrams_tibble %>% 
                                  rename(song = V1)
bigram_cols <- grepl('song',names(dtm_triad_bigrams_tibble)) == F
dtm_triad_bigrams_tibble<- dtm_triad_bigrams_tibble %>% 
                                      mutate_if(.predicate = bigram_cols,
                                                as.integer)

dtm_triad_bigram_dist <- dtm_triad_bigrams_tibble %>% 
                                select(-song) %>% 
                                dist(method = 'manhattan')

hc <- hclust(dtm_triad_bigram_dist)
plot(hc)
h_cut <- 14.5
abline(h = h_cut, lty = 'dashed', col = 'red')

groups <- cutree(hc, h = h_cut)
dtm_triad_bigrams_tibble$group  <- groups

distinct_song_info <- song_info %>%  distinct(song, .keep_all = T)
dtm_triad_bigrams_tibble %>% 
  left_join(distinct_song_info) %>% 
  ggplot(aes(x= year, y = group, color = as.factor(group))) +
  geom_point() +
  geom_jitter()

```


#Triad Bigrams 
```{r}

#Merge Chords from each song_part into single vector for each song  
df_triads <- beatles %>% 
                merge_song_parts(features = F)

#Remove chords repeated in sequence 
df_triads$roman <- df_triads$roman %>% 
                          lapply(remove_duplicates) %>%  unlist

#Convert to bigrams
df_triad_bigrams <- convert_to_ngrams(df = df_triads, n = 2, features = F)


#Number of Bigrams
n_bigrams <- 20

#Get top bigrams (By Number of Songs that contain each bigram)
top_triads_bigrams <- df_triad_bigrams  %>% 
                              distinct(song, bigram) %>% 
                              count( bigram, sort = T) %>% 
                              slice(1:n_bigrams)

#Create DTM object 
dtm_triad_bigrams <- df_triad_bigrams %>%
                          inner_join(top_20_triad_bigrams, by = 'bigram') %>% 
                          mutate(n = 1) %>% 
                          cast_dtm(document = song, 
                                   term = bigram,
                                   value = n, 
                                   weighting = tm::weightTf)

dtm_tibble_triad_bigrams <- convert_to_tibble(dtm_triad_bigrams )

```


#Hierarchical Clustering 
```{r}

#Calculate Distance Matrix
dtm_triad_bigram_dist <- dtm_tibble_triad_bigrams %>% 
                                select(-song) %>% 
                                dist(method = 'manhattan')
?hclust
hc <- hclust(dtm_triad_bigram_dist )
h_cut <- 13.5 #Determine height cutpoint
plot(hc)
abline(h = h_cut, lty = 'dashed', col = 'red')
groups <- cutree(hc, h = h_cut)

#### Dendrogram Code ? 
# hc_dendrogram <- as.dendrogram(hc)
# hc_dendrogram <- cut(x =hc_dendrogram, h = 13)
# plot(hc_dendrogram)
```

## Merge Clusters
```{r}
#Label Groups 
dtm_tibble_triad_bigrams$group  <- groups

#Merge DTM_Tibble with song info 
distinct_song_info <- song_info %>%  distinct(song, .keep_all = T)
full_tibble_triad_bigrams <- dtm_tibble_triad_bigrams  %>% 
                                  left_join(full_distinct_song_info, by = 'song')

dtm_tibble_triad_bigrams %>% 
  count(group)
```



#Plot Clusters by year
```{r}
#Plot Clusters by year
full_tibble_triad_bigrams %>% 
  ggplot(aes(x= year, y = group, color = as.factor(group))) +
  geom_jitter()
```


#Plot Clusters by Composer
```{r}
#Plot Clusters by Composer
full_tibble_triad_bigrams %>% 
  ggplot(aes(x= composer, y = group, color = as.factor(group))) +
  geom_jitter()
```


```{r}

# NOTE: CREATE FUNCTION TO LOOK AT MEANS 

# dtm_tibble_triad_bigrams  %>% 
#   filter(group == i) %>% 
#   select(- group) %>% 
#   gather(key = bigram, value = n, - song) %>% 
#   group_by(bigram) %>% 
#   summarize(bigram_mean = mean(n)) %>% 
#   arrange(desc(bigram_mean))



```



#Features Bigrams 
```{r}

#Merge Chords from each song_part into single vector for each song  
df_features <- beatles %>% 
                merge_song_parts(features = T)

#Remove chords repeated in sequence 
df_features$roman_features <- df_features$roman_features %>% 
                          lapply(remove_duplicates) %>%  unlist

#Convert to bigrams
df_feature_bigrams <- convert_to_ngrams(df = df_features, n = 2, features = T)
#Number of Bigrams
n_bigrams <- 20

#Get top bigrams (By Number of Songs that contain each bigram)
top_feature_bigrams <- df_feature_bigrams  %>% 
                              distinct(song, bigram) %>% 
                              count( bigram, sort = T) %>% 
                              slice(1:n_bigrams)

#Create DTM object 
dtm_feature_bigrams <- df_feature_bigrams %>%
                          inner_join(top_feature_bigrams, by = 'bigram') %>% 
                          mutate(n = 1) %>% 
                          cast_dtm(document = song, 
                                   term = bigram,
                                   value = n, 
                                   weighting = tm::weightTf)

dtm_tibble_feature_bigrams <- convert_to_tibble(dtm_feature_bigrams )

```


#Hierarchical Clustering 
```{r}

#Calculate Distance Matrix
bigram_feature_dist <- dtm_tibble_feature_bigrams %>% 
                                select(-song) %>% 
                                dist(method = 'manhattan')

hc <- hclust(bigram_feature_dist  )
h_cut <- 13.2 #Determine height cutpoint
plot(hc)
abline(h = h_cut, lty = 'dashed', col = 'red')
groups <- cutree(hc, h = h_cut)
```

## Merge Clusters
```{r}
#Label Groups 
dtm_tibble_feature_bigrams$group  <- groups

#Merge DTM_Tibble with song info 
distinct_song_info <- song_info %>%  distinct(song, .keep_all = T)
full_feature_bigrams <- dtm_tibble_feature_bigrams  %>% 
                                  left_join(full_distinct_song_info, by = 'song')

full_feature_bigrams %>% 
  count(group)
```



#Plot Clusters by Composer
```{r}
#Plot Clusters by Composer
full_feature_bigrams %>% 
  ggplot(aes(x= composer, y = group, color = as.factor(group))) +
  geom_jitter()
```


### Triad Trigrams
```{r}
l <- beatles %>%  
          split(f = beatles$song) %>% 
          lapply(function(x) data.frame(artist = unique(x$artist), 
                                song = unique(x$song), 
                                roman= paste(x$roman, collapse = '-')))
df_triads <- suppressWarnings(bind_rows(l)) 

df_triads$roman_triads <- df_triads$romans %>% 
                                  lapply(remove_duplicates) %>%  unlist

df_triad_trigrams <- df_triads %>% 
                         mutate(roman= str_replace_all(roman, '/', 'BORROWED'),
                                roman  = str_remove_all(roman, '\\('),
                                roman = str_remove_all(roman, '\\)')) %>% 
                        unnest_tokens(trigram, roman, token = 'ngrams', n = 3,
                                        to_lower = F)  
#Replace as /(*)
df_triad_trigrams$trigram <- df_triad_trigrams$trigram %>% 
                        lapply(function(x) {
                                  x_chord <- str_split(x, pattern = '\\s', simplify = T)
                             
                                  borrow_logical <- grepl('BORROWED',x_chord)
                               
                                  x_chord[borrow_logical] <- paste0(x_chord[borrow_logical], ')')
                                  new_x <- paste(x_chord, collapse = ' ')
                                  new_x <- str_replace_all(new_x, "BORROWED", "/(")
                                  return(   new_x)}) %>% 
                                   unlist



```


```{r}

top_triad_trigrams <- df_triad_trigrams  %>% 
                            count(trigram, sort = T) %>% 
                            slice(1:20)


dtm_triad_trigrams <- df_triad_trigrams  %>%
                          distinct(song, trigram) %>% 
                          inner_join(top_triad_trigrams , by = 'trigram') %>% 
                          mutate(n = 1) %>% 
                          cast_dtm(document = song, 
                                   term = trigram,
                                   value = n, 
                                   weighting = tm::weightTf)

 
#Convert from DTM into Tibble (WRITE FUNCTION FOR THIS)
dtm_triad_trigram_tibble <-  cbind(dtm_triad_trigrams$dimnames$Docs, 
                                      as.matrix(dtm_triad_trigrams)) %>% 
                                      as.tibble()
dtm_triad_trigram_tibble <- dtm_triad_trigram_tibble %>% 
                                  rename(song = V1)
trigram_cols <- grepl('song',names(dtm_triad_trigram_tibble )) == F
dtm_triad_trigram_tibble <- dtm_triad_trigram_tibble  %>% 
                                      mutate_if(.predicate = trigram_cols,
                                                as.integer)
```



```{r}
dtm_triad_trigram_dist <- dtm_triad_trigram_tibble %>% 
                                select(-song) %>% 
                                dist(method = 'manhattan')

hc <- hclust(dtm_triad_trigram_dist)
plot(hc)
h_cut <- 12.5
abline(h = h_cut, lty = 'dashed', col = 'red')

groups <- cutree(hc, h = h_cut)
dtm_triad_trigram_tibble$group  <- groups
```


```{r}

full_triad_trigram <- dtm_triad_trigram_tibble %>% 
  left_join(full_distinct_song_info, by = 'song')
full_triad_trigram %>% 
  count(group)

```

```{r}
full_triad_trigram %>% 
  ggplot(aes(x= year, y = group, color = as.factor(group))) +
  geom_jitter()
```



```{r}
full_triad_trigram %>% 
  ggplot(aes(x= composer, y = group, color = as.factor(group))) +
  geom_jitter()
```


### Features Trigrams
```{r}

df_features <- beatles %>%  
                  merge_song_parts(features = T)
      
df_triads$roman <- df_triads$roman %>% 
                                lapply(remove_duplicates) %>%  unlist

df_triad_trigrams <- df_triads %>% 
                         mutate(roman = str_replace_all(roman, '/', 'BORROWED'),
                                roman = str_remove_all(roman, '\\('),
                                roman = str_remove_all(roman, '\\)')) %>% 
                        unnest_tokens(trigram, roman, token = 'ngrams', n = 3,
                                        to_lower = F)  
#Replace as /(*)
df_triad_trigrams$trigram <- df_triad_trigrams$trigram %>% 
                        lapply(function(x) {
                                  x_chord <- str_split(x, pattern = '\\s', simplify = T)
                             
                                  borrow_logical <- grepl('BORROWED',x_chord)
                               
                                  x_chord[borrow_logical] <- paste0(x_chord[borrow_logical], ')')
                                  new_x <- paste(x_chord, collapse = ' ')
                                  new_x <- str_replace_all(new_x, "BORROWED", "/(")
                                  return(   new_x)}) %>% 
                                   unlist
```



# Triad Trigrams:K-means 
```{r}

k_mod <- dtm_triad_trigram_tibble %>% 
          select(-song) %>% 
          kmeans(centers = 4)
dtm_triad_trigram_tibble$cluster <- k_mod$cluster
dtm_triad_trigram_tibble_info <-   dtm_triad_trigram_tibble %>% 
                                        inner_join(full_distinct_song_info, by = 'song') 

```



```{r}
dtm_triad_trigram_tibble_info %>% 
      ggplot(aes(x= year, y= cluster, color = as.factor(cluster))) +
      geom_jitter()
``` 

```{r}
dtm_triad_trigram_tibble_info %>% 
      ggplot(aes(x= composer, y= cluster, color = as.factor(cluster))) +

      geom_jitter()

```


#Look at Clusters
```{r}
dtm_triad_trigram_tibble_info %>% 
  filter(cluster == 1)

dtm_triad_trigram_tibble_info %>% 
  filter(cluster == 2)


dtm_triad_trigram_tibble_info %>% 
  filter(cluster == 3)


dtm_triad_trigram_tibble_info %>% 
  filter(cluster == 4)


dtm_triad_trigram_tibble_info %>% 
  filter(cluster == 5)
```


```{r}
for(i in 1:length(unique(dtm_triad_trigram_tibble$cluster))){
  x <- dtm_triad_trigram_tibble %>% 
  filter(cluster == i) %>%  
  gather(key = trigram, value = n, -song, -cluster) %>% 
  group_by(cluster, trigram) %>% 
  summarize(trigram_mean = mean(n)) %>% 
  arrange(desc(trigram_mean))
  print(x)
  
  
}


```




#Try Binomial Logistic Regression based on Chord Group Percentages
```{r}
mod <- glm(as.factor(phase) ~  pct_borrowed_sum, data = pct_chord_tab, family = binomial(link = 'logit') ) 

mod1 <- glm(as.factor(phase) ~ 
                      pct_borrowed_sum + pct_dom_sum , data = pct_chord_tab, family = binomial(link = 'logit') ) 



mod2 <- glm(as.factor(phase) ~ pct_dom_sum+ 
                      pct_borrowed_sum +
                      pct_minor_sum, data = pct_chord_tab, family = binomial(link = 'logit') ) 
anova(mod, mod1, test = 'Chisq')



mod3 <- glm(as.factor(phase) ~ 
                      pct_borrowed_sum*pct_dom_sum , data = pct_chord_tab, family = binomial(link = 'logit') ) 


mod4 <- glm(as.factor(phase) ~ 
                      pct_borrowed_sum*pct_dom_sum + num_chords, data = pct_chord_tab, family = binomial(link = 'logit') ) 


mod5 <- glm(as.factor(phase) ~ 
                      pct_borrowed_sum +pct_dom_sum + num_chords, data = pct_chord_tab, family = binomial(link = 'logit') ) 

mod %>%  summary
mod1 %>%  summary
mod2 %>%  summary
mod3 %>%  summary
mod4 %>%  summary
mod5 %>%  summary

anova(mod, mod3, test = 'Chisq')

```

### Next Step: ANALYSIS
I'm considering two options:
1) Use hierarchical modeling to find clusters of Beatles songs.  This would  be similar to the *Beatles Genome Project*.  
2) Create a train/test split.  Then use either naive Bayes or logistic regression to create a model to classify early versus late Beatles songs based on the training data.  Use cross-validation to select the best model.  Then after selecting a model, evaluate its performance on the test data with the goal of achieving 80% or higher AUC. 

### Issues to Consider
1) My data does not contain the entire song, but rather one line from each section of a song.  Consequently, I am not sure term frequency is an accurate measure of the salience of a certain chord bigram or trigram in the same way it would be in a literary document.  
2) The model may not distinguish properly between similar chords.  For example, Cmaj7, Cadd9, and Cmaj can have the same function within the song.  I may consider editing some chords.
3) I am not sure how sparseness will affect my analysis and if I should limit the number of bigrams/trigrams used to train the model or if I should use the full corpus. 
4) A few songs only include one part of the song, which may skew the analysis.  I may want to consider removing these songs from the dataset. 

#### Works Cited
* The Beatles Genome Project: Cluster Analysis and Visualization of Popular Music, Douglas J. Mason, VisWeek, October 2012.
* Tomasky Michael. (February 2014) 'Was The Beatles Music Really That Unique? Yeah It Totally Was?'. Retreived from https://www.thedailybeast.com/was-the-beatles-music-really-that-unique-yeah-it-totally-was
* Carlos PÃ©rez-Sancho, David Rizo & JosÃ© M. IÃ±esta (2009) Genre classification using chords and stochastic language models, Connection Science, 21:2-3, 145-159, DOI: 10.1080/09540090902733780.
